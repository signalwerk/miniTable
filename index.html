<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>miniTable - Three.js 3D Model</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        font-family: system-ui, -apple-system, sans-serif;
        display: flex;
        height: 100vh;
        background-color: #f5f5f5;
      }

      #controls {
        width: 300px;
        padding: 20px;
        background-color: #f0f0f0;
        border-right: 1px solid #ddd;
        overflow-y: auto;
      }

      #canvas-container {
        flex: 1;
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: #ffeb3b; /* Yellow background */
      }

      canvas {
        display: block;
        cursor: move;
      }

      .control-group {
        margin-bottom: 15px;
      }

      label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
      }

      .input-wrapper {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      input[type="range"] {
        flex: 1;
      }

      input[type="number"] {
        width: 60px;
        padding: 4px;
        border: 1px solid #ccc;
        border-radius: 3px;
      }

      .unit {
        font-size: 12px;
        color: #666;
      }

      h1 {
        margin-top: 0;
        font-size: 24px;
      }

      button {
        padding: 8px 12px;
        background-color: #4caf50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        margin-top: 10px;
      }

      button:hover {
        background-color: #45a049;
      }
    </style>
  </head>
  <body>
    <div id="controls">
      <h1>miniTable</h1>

      <div class="control-group">
        <label>Table Top Length:</label>
        <div class="input-wrapper">
          <input
            type="range"
            id="topLength"
            min="450"
            max="3000"
            value="1200"
          />
          <input
            type="number"
            id="topLengthNum"
            min="450"
            max="3000"
            value="1200"
          />
          <span class="unit">mm</span>
        </div>
      </div>

      <div class="control-group">
        <label>Table Top Width:</label>
        <div class="input-wrapper">
          <input type="range" id="topWidth" min="450" max="3000" value="800" />
          <input
            type="number"
            id="topWidthNum"
            min="450"
            max="3000"
            value="800"
          />
          <span class="unit">mm</span>
        </div>
      </div>

      <div class="control-group">
        <label>Table Top Thickness:</label>
        <div class="input-wrapper">
          <input type="range" id="topHeight" min="5" max="80" value="40" />
          <input type="number" id="topHeightNum" min="5" max="80" value="40" />
          <span class="unit">mm</span>
        </div>
      </div>

      <div class="control-group">
        <label>Bar/Leg Width:</label>
        <div class="input-wrapper">
          <input type="range" id="barWidth" min="5" max="80" value="30" />
          <input type="number" id="barWidthNum" min="5" max="80" value="30" />
          <span class="unit">mm</span>
        </div>
      </div>

      <div class="control-group">
        <label>Bar/Leg Height:</label>
        <div class="input-wrapper">
          <input type="range" id="barHeight" min="5" max="80" value="50" />
          <input type="number" id="barHeightNum" min="5" max="80" value="50" />
          <span class="unit">mm</span>
        </div>
      </div>

      <div class="control-group">
        <label>Leg Height:</label>
        <div class="input-wrapper">
          <input type="range" id="legHeight" min="300" max="1000" value="700" />
          <input
            type="number"
            id="legHeightNum"
            min="300"
            max="1000"
            value="700"
          />
          <span class="unit">mm</span>
        </div>
      </div>

      <button id="resetCamera">Reset Camera</button>
    </div>

    <div id="canvas-container">
      <canvas id="three-canvas"></canvas>
    </div>

    <script>
      // Initialize Three.js scene
      const canvasContainer = document.getElementById("canvas-container");
      const canvas = document.getElementById("three-canvas");

      // Set canvas size
      canvas.width = canvasContainer.clientWidth;
      canvas.height = canvasContainer.clientHeight;

      // Create scene
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffeb3b); // Yellow background

      // Camera
      const camera = new THREE.PerspectiveCamera(
        45,
        canvas.width / canvas.height,
        1,
        10000,
      );
      camera.position.set(0, 0, 2000);

      // Renderer
      const renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        antialias: true,
      });
      renderer.setSize(canvas.width, canvas.height);

      // Add lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(1, 1, 1);
      scene.add(directionalLight);

      // OrbitControls
      const controls = new THREE.OrbitControls(camera, canvas);
      controls.enableDamping = true;
      controls.dampingFactor = 0.1;
      controls.rotateSpeed = 0.5;
      controls.enablePan = true;
      controls.minDistance = 500;  // Minimum zoom distance
      controls.maxDistance = 5000; // Maximum zoom distance
      
      // Allow full rotation in all directions
      controls.minPolarAngle = 0;
      controls.maxPolarAngle = Math.PI;
      
      let isAutoRotating = true;
      controls.autoRotate = isAutoRotating;
      controls.autoRotateSpeed = 1.0;
      
      controls.addEventListener("start", function () {
        isAutoRotating = false;
        controls.autoRotate = false;
      });

      // Group to hold all table parts
      const tableGroup = new THREE.Group();
      scene.add(tableGroup);
      
      // Initial rotation to match original orientation
      // tableGroup.rotation.x = -Math.PI / 6; // Adjusted rotation to put table top on top
      
      // Scale factor to make the model fit well in the scene (similar to Zdog's zoom)
      const scaleFactor = 0.5;
      tableGroup.scale.set(scaleFactor, scaleFactor, scaleFactor);

      // Global styling constants
      const styles = {
        fill: "rgb(255, 255, 255)",
        stroke: "black",
        outlineOffset: 0.2,
        strokeWidth: 6,
        legInset: 0.1,
      };

      // Parameters
      let params = {
        topLength: 1200,
        topWidth: 800,
        topHeight: 40,
        legHeight: 700,
        barWidth: 30,
        barHeight: 50,
      };

      // Materials
      const fillMaterial = new THREE.MeshLambertMaterial({
        color: 0xffffff,
        // opacity: 0.7,
        transparent: true,
      });

      const strokeMaterial = new THREE.LineBasicMaterial({
        color: 0x000000,
        linewidth: 20, // Note: linewidth may not work on all platforms due to WebGL limitations
      });

      // Create a box with fill and outline
      function createBox(options) {
        // Inner box (filled)
        const geometry = new THREE.BoxGeometry(
          options.width,
          options.height,
          options.depth,
        );

        const mesh = new THREE.Mesh(geometry, fillMaterial);

        if (options.translate) {
          mesh.position.set(
            options.translate.x || 0,
            -(options.translate.y || 0), // Invert Y position to fix orientation
            options.translate.z || 0,
          );
        }

        tableGroup.add(mesh);

        // Create edges (outline)
        const edgesGeometry = new THREE.EdgesGeometry(geometry);
        const outline = new THREE.LineSegments(edgesGeometry, strokeMaterial);

        // Match the position of the main mesh
        outline.position.copy(mesh.position);

        tableGroup.add(outline);

        return { mesh, outline };
      }

      // Create table parts
      function createTable() {
        // Remove all existing parts
        while (tableGroup.children.length > 0) {
          const child = tableGroup.children[0];
          tableGroup.remove(child);

          // Dispose geometries to prevent memory leaks
          if (child.geometry) {
            child.geometry.dispose();
          }
        }

        // Table top
        createBox({
          width: params.topLength,
          height: params.topHeight,
          depth: params.topWidth,
        });

        // Calculate leg inset distances
        const barSizeInset = Math.min(params.barWidth, params.barHeight) * 3;
        const lengthInset = barSizeInset;
        const widthInset = barSizeInset;

        // Legs
        const legPositions = [
          {
            x: params.topLength / 2 - barSizeInset - params.barWidth / 2,
            z: params.topWidth / 2 - widthInset - params.barHeight / 2,
          },
          {
            x: -params.topLength / 2 + barSizeInset + params.barWidth / 2,
            z: params.topWidth / 2 - widthInset - params.barHeight / 2,
          },
          {
            x: -params.topLength / 2 + barSizeInset + params.barWidth / 2,
            z: -params.topWidth / 2 + widthInset + params.barHeight / 2,
          },
          {
            x: params.topLength / 2 - barSizeInset - params.barWidth / 2,
            z: -params.topWidth / 2 + widthInset + params.barHeight / 2,
          },
        ];

        legPositions.forEach((pos) => {
          createBox({
            width: params.barWidth,
            height: params.legHeight,
            depth: params.barHeight,
            translate: {
              x: pos.x,
              y: params.legHeight / 2 + params.topHeight / 2,
              z: pos.z,
            },
          });
        });

        // Support bars (front and back)
        createBox({
          width:
            params.topLength -
            barSizeInset * 2 +
            4 * Math.min(params.barWidth, params.barHeight),
          height: params.barHeight,
          depth: params.barWidth,
          translate: {
            y: params.topHeight / 2 + params.barHeight / 2,
            z: params.topWidth / 2 - widthInset + params.barWidth / 2,
          },
        });

        createBox({
          width:
            params.topLength -
            barSizeInset * 2 +
            4 * Math.min(params.barWidth, params.barHeight),
          height: params.barHeight,
          depth: params.barWidth,
          translate: {
            y: params.topHeight / 2 + params.barHeight / 2,
            z: -(params.topWidth / 2 - widthInset + params.barWidth / 2),
          },
        });

        // Support bars (left and right)
        createBox({
          width: params.barWidth,
          height: params.barHeight,
          depth:
            params.topWidth -
            widthInset * 2 +
            4 * Math.min(params.barWidth, params.barHeight),
          translate: {
            x: params.topLength / 2 - barSizeInset + params.barWidth / 2,
            y: params.topHeight / 2 + params.barHeight / 2 + params.barHeight,
          },
        });

        createBox({
          width: params.barWidth,
          height: params.barHeight,
          depth:
            params.topWidth -
            widthInset * 2 +
            4 * Math.min(params.barWidth, params.barHeight),
          translate: {
            x: -(params.topLength / 2 - barSizeInset + params.barWidth / 2),
            y: params.topHeight / 2 + params.barHeight / 2 + params.barHeight,
          },
        });
      }

      // Initial table creation
      createTable();

      // Handle window resize
      window.addEventListener("resize", () => {
        canvas.width = canvasContainer.clientWidth;
        canvas.height = canvasContainer.clientHeight;

        camera.aspect = canvas.width / canvas.height;
        camera.updateProjectionMatrix();

        renderer.setSize(canvas.width, canvas.height);
      });

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);

        controls.update(); // Required for OrbitControls

        renderer.render(scene, camera);
      }
      animate();

      // UI controls
      const sliders = {
        topLength: document.getElementById("topLength"),
        topWidth: document.getElementById("topWidth"),
        topHeight: document.getElementById("topHeight"),
        legHeight: document.getElementById("legHeight"),
        barWidth: document.getElementById("barWidth"),
        barHeight: document.getElementById("barHeight"),
      };

      const numberInputs = {
        topLength: document.getElementById("topLengthNum"),
        topWidth: document.getElementById("topWidthNum"),
        topHeight: document.getElementById("topHeightNum"),
        legHeight: document.getElementById("legHeightNum"),
        barWidth: document.getElementById("barWidthNum"),
        barHeight: document.getElementById("barHeightNum"),
      };

      // Update functions for sliders
      Object.keys(sliders).forEach((key) => {
        // Update number input when slider changes
        sliders[key].addEventListener("input", () => {
          const value = parseFloat(sliders[key].value);
          params[key] = value;
          numberInputs[key].value = value;
          createTable();
        });

        // Update slider when number input changes
        numberInputs[key].addEventListener("input", () => {
          const value = parseFloat(numberInputs[key].value);
          // Clamp value to min/max
          const min = parseFloat(sliders[key].min);
          const max = parseFloat(sliders[key].max);
          const clampedValue = Math.max(min, Math.min(max, value));

          params[key] = clampedValue;
          numberInputs[key].value = clampedValue;
          sliders[key].value = clampedValue;
          createTable();
        });
      });

      // Reset camera
      document.getElementById("resetCamera").addEventListener("click", () => {
        // Reset camera to initial position
        controls.reset();
        
        // Reset table orientation
        tableGroup.rotation.x = -Math.PI / 6; // Adjusted rotation to put table top on top
        tableGroup.rotation.y = 0;
        tableGroup.rotation.z = 0;
        
        // Enable auto-rotation again
        isAutoRotating = true;
        controls.autoRotate = true;
      });
    </script>
  </body>
</html>
