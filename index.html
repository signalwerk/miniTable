<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>miniTable - Three.js Line-Art Model</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.136.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.136.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.5/dat.gui.min.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        font-family: system-ui, -apple-system, sans-serif;
        display: flex;
        height: 100vh;
        background-color: #f5f5f5;
      }

      #controls {
        width: 300px;
        padding: 20px;
        background-color: #f0f0f0;
        border-right: 1px solid #ddd;
        overflow-y: auto;
      }

      #canvas-container {
        flex: 1;
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: #ffeb3b; /* Yellow background */
      }

      canvas {
        display: block;
        cursor: move;
      }

      .control-group {
        margin-bottom: 15px;
      }

      label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
      }

      .input-wrapper {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      input[type="range"] {
        flex: 1;
      }

      input[type="number"] {
        width: 60px;
        padding: 4px;
        border: 1px solid #ccc;
        border-radius: 3px;
      }

      .unit {
        font-size: 12px;
        color: #666;
      }

      h1 {
        margin-top: 0;
        font-size: 24px;
      }

      button {
        padding: 8px 12px;
        background-color: #4caf50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        margin-top: 10px;
      }

      button:hover {
        background-color: #45a049;
      }

      /* Added style for dat.gui */
      .dg.ac {
        z-index: 1000 !important;
      }
    </style>
  </head>
  <body>
    <div id="controls">
      <h1>miniTable</h1>

      <div class="control-group">
        <label>Table Top Length:</label>
        <div class="input-wrapper">
          <input
            type="range"
            id="topLength"
            min="450"
            max="3000"
            value="1200"
          />
          <input
            type="number"
            id="topLengthNum"
            min="450"
            max="3000"
            value="1200"
          />
          <span class="unit">mm</span>
        </div>
      </div>

      <div class="control-group">
        <label>Table Top Width:</label>
        <div class="input-wrapper">
          <input type="range" id="topWidth" min="450" max="3000" value="800" />
          <input
            type="number"
            id="topWidthNum"
            min="450"
            max="3000"
            value="800"
          />
          <span class="unit">mm</span>
        </div>
      </div>

      <div class="control-group">
        <label>Table Top Thickness:</label>
        <div class="input-wrapper">
          <input type="range" id="topHeight" min="5" max="80" value="40" />
          <input type="number" id="topHeightNum" min="5" max="80" value="40" />
          <span class="unit">mm</span>
        </div>
      </div>

      <div class="control-group">
        <label>Bar/Leg Width:</label>
        <div class="input-wrapper">
          <input type="range" id="barWidth" min="5" max="80" value="30" />
          <input type="number" id="barWidthNum" min="5" max="80" value="30" />
          <span class="unit">mm</span>
        </div>
      </div>

      <div class="control-group">
        <label>Bar/Leg Height:</label>
        <div class="input-wrapper">
          <input type="range" id="barHeight" min="5" max="80" value="50" />
          <input type="number" id="barHeightNum" min="5" max="80" value="50" />
          <span class="unit">mm</span>
        </div>
      </div>

      <div class="control-group">
        <label>Leg Height:</label>
        <div class="input-wrapper">
          <input type="range" id="legHeight" min="300" max="1000" value="700" />
          <input
            type="number"
            id="legHeightNum"
            min="300"
            max="1000"
            value="700"
          />
          <span class="unit">mm</span>
        </div>
      </div>

      <button id="resetCamera">Reset Camera</button>
    </div>

    <div id="canvas-container">
      <canvas id="three-canvas"></canvas>
    </div>

    <script>
      // Shader definitions
      const vertexShader = `
        varying vec2 vUv;
        varying vec3 vPosition;
        
        void main() {
          vUv = uv;
          vPosition = position;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `;
      
      const fragmentShader = `
        varying vec2 vUv;
        varying vec3 vPosition;
        uniform float thickness;
        uniform vec3 color;
        uniform vec3 backgroundColor;
        
        float edgeFactor(vec2 p) {
          vec2 grid = abs(fract(p - 0.5) - 0.5) / fwidth(p) / thickness;
          return min(grid.x, grid.y);
        }
        
        void main() {
          // Create grid lines on all faces
          float a = edgeFactor(vUv);
          
          // Mix the line color with the background color
          vec3 finalColor = mix(color, backgroundColor, a);
          
          gl_FragColor = vec4(finalColor, 1.0);
        }
      `;

      // Initialize Three.js scene
      const canvasContainer = document.getElementById("canvas-container");
      const canvas = document.getElementById("three-canvas");

      // Set canvas size
      canvas.width = canvasContainer.clientWidth;
      canvas.height = canvasContainer.clientHeight;

      // Create scene
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffeb3b); // Yellow background

      // Camera
      const camera = new THREE.PerspectiveCamera(
        45,
        canvas.width / canvas.height,
        1,
        10000,
      );
      camera.position.set(0, 0, 2000);

      // Renderer
      const renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        antialias: true,
      });
      renderer.setSize(canvas.width, canvas.height);

      // OrbitControls
      const controls = new THREE.OrbitControls(camera, canvas);
      controls.enableDamping = true;
      controls.dampingFactor = 0.1;
      controls.rotateSpeed = 0.5;
      controls.enablePan = true;
      controls.minDistance = 500;  // Minimum zoom distance
      controls.maxDistance = 5000; // Maximum zoom distance
      
      // Allow full rotation in all directions
      controls.minPolarAngle = 0;
      controls.maxPolarAngle = Math.PI;
      
      let isAutoRotating = true;
      controls.autoRotate = isAutoRotating;
      controls.autoRotateSpeed = 1.0;
      
      controls.addEventListener("start", function () {
        isAutoRotating = false;
        controls.autoRotate = false;
      });

      // Group to hold all table parts
      const tableGroup = new THREE.Group();
      scene.add(tableGroup);
      
      // Scale factor to make the model fit well in the scene
      const scaleFactor = 0.5;
      tableGroup.scale.set(scaleFactor, scaleFactor, scaleFactor);

      // Shader material for line-art effect
      const lineMaterial = new THREE.ShaderMaterial({
        uniforms: {
          thickness: { value: 1.5 },
          color: { value: new THREE.Color(0x000000) },
          backgroundColor: { value: new THREE.Color(0xffffff) }
        },
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        transparent: true
      });
      
      // Create GUI for shader controls
      const gui = new dat.GUI({ autoPlace: true });
      gui.domElement.style.position = 'absolute';
      gui.domElement.style.top = '10px';
      gui.domElement.style.right = '10px';
      
      gui.add(lineMaterial.uniforms.thickness, 'value', 0.5, 3.0).name('Line Thickness');
      const colorController = gui.addColor({ color: '#000000' }, 'color').name('Line Color');
      colorController.onChange(function(value) {
        lineMaterial.uniforms.color.value.set(value);
      });
      
      const bgColorController = gui.addColor({ color: '#ffffff' }, 'color').name('Fill Color');
      bgColorController.onChange(function(value) {
        lineMaterial.uniforms.backgroundColor.value.set(value);
      });
      
      // Parameters
      let params = {
        topLength: 1200,
        topWidth: 800,
        topHeight: 40,
        legHeight: 700,
        barWidth: 30,
        barHeight: 50,
      };
      
      // Create a box with the line-art shader
      function createBox(options) {
        // Create the box geometry
        const geometry = new THREE.BoxGeometry(
          options.width, 
          options.height, 
          options.depth,
        );
        
        // Create the mesh with the line-art material
        const mesh = new THREE.Mesh(geometry, lineMaterial);
        
        // Set position
        if (options.translate) {
          mesh.position.set(
            options.translate.x || 0,
            -(options.translate.y || 0), // Invert Y position for correct orientation
            options.translate.z || 0,
          );
        }
        
        tableGroup.add(mesh);
        return mesh;
      }
      
      // Create table parts
      function createTable() {
        // Remove all existing parts
        while (tableGroup.children.length > 0) {
          const child = tableGroup.children[0];
          tableGroup.remove(child);
          
          // Dispose geometries to prevent memory leaks
          if (child.geometry) {
            child.geometry.dispose();
          }
        }
        
        // Table top
        createBox({
          width: params.topLength,
          height: params.topHeight,
          depth: params.topWidth,
        });
        
        // Calculate leg inset distances
        const barSizeInset = Math.min(params.barWidth, params.barHeight) * 3;
        const lengthInset = barSizeInset;
        const widthInset = barSizeInset;
        
        // Legs
        const legPositions = [
          {
            x: params.topLength / 2 - barSizeInset - params.barWidth / 2,
            z: params.topWidth / 2 - widthInset - params.barHeight / 2,
          },
          {
            x: -params.topLength / 2 + barSizeInset + params.barWidth / 2,
            z: params.topWidth / 2 - widthInset - params.barHeight / 2,
          },
          {
            x: -params.topLength / 2 + barSizeInset + params.barWidth / 2,
            z: -params.topWidth / 2 + widthInset + params.barHeight / 2,
          },
          {
            x: params.topLength / 2 - barSizeInset - params.barWidth / 2,
            z: -params.topWidth / 2 + widthInset + params.barHeight / 2,
          },
        ];
        
        legPositions.forEach((pos) => {
          createBox({
            width: params.barWidth,
            height: params.legHeight,
            depth: params.barHeight,
            translate: {
              x: pos.x,
              y: params.legHeight / 2 + params.topHeight / 2,
              z: pos.z,
            },
          });
        });
        
        // Support bars (front and back)
        createBox({
          width:
            params.topLength -
            barSizeInset * 2 +
            4 * Math.min(params.barWidth, params.barHeight),
          height: params.barHeight,
          depth: params.barWidth,
          translate: {
            y: params.topHeight / 2 + params.barHeight / 2,
            z: params.topWidth / 2 - widthInset + params.barWidth / 2,
          },
        });
        
        createBox({
          width:
            params.topLength -
            barSizeInset * 2 +
            4 * Math.min(params.barWidth, params.barHeight),
          height: params.barHeight,
          depth: params.barWidth,
          translate: {
            y: params.topHeight / 2 + params.barHeight / 2,
            z: -(params.topWidth / 2 - widthInset + params.barWidth / 2),
          },
        });
        
        // Support bars (left and right)
        createBox({
          width: params.barWidth,
          height: params.barHeight,
          depth:
            params.topWidth -
            widthInset * 2 +
            4 * Math.min(params.barWidth, params.barHeight),
          translate: {
            x: params.topLength / 2 - barSizeInset + params.barWidth / 2,
            y: params.topHeight / 2 + params.barHeight / 2 + params.barHeight,
          },
        });
        
        createBox({
          width: params.barWidth,
          height: params.barHeight,
          depth:
            params.topWidth -
            widthInset * 2 +
            4 * Math.min(params.barWidth, params.barHeight),
          translate: {
            x: -(params.topLength / 2 - barSizeInset + params.barWidth / 2),
            y: params.topHeight / 2 + params.barHeight / 2 + params.barHeight,
          },
        });
      }
      
      // Initial table creation
      createTable();
      
      // Handle window resize
      window.addEventListener("resize", () => {
        canvas.width = canvasContainer.clientWidth;
        canvas.height = canvasContainer.clientHeight;
        
        camera.aspect = canvas.width / canvas.height;
        camera.updateProjectionMatrix();
        
        renderer.setSize(canvas.width, canvas.height);
      });
      
      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        
        controls.update(); // Required for OrbitControls
        
        renderer.render(scene, camera);
      }
      animate();
      
      // UI controls
      const sliders = {
        topLength: document.getElementById("topLength"),
        topWidth: document.getElementById("topWidth"),
        topHeight: document.getElementById("topHeight"),
        legHeight: document.getElementById("legHeight"),
        barWidth: document.getElementById("barWidth"),
        barHeight: document.getElementById("barHeight"),
      };
      
      const numberInputs = {
        topLength: document.getElementById("topLengthNum"),
        topWidth: document.getElementById("topWidthNum"),
        topHeight: document.getElementById("topHeightNum"),
        legHeight: document.getElementById("legHeightNum"),
        barWidth: document.getElementById("barWidthNum"),
        barHeight: document.getElementById("barHeightNum"),
      };
      
      // Update functions for sliders
      Object.keys(sliders).forEach((key) => {
        // Update number input when slider changes
        sliders[key].addEventListener("input", () => {
          const value = parseFloat(sliders[key].value);
          params[key] = value;
          numberInputs[key].value = value;
          createTable();
        });
        
        // Update slider when number input changes
        numberInputs[key].addEventListener("input", () => {
          const value = parseFloat(numberInputs[key].value);
          // Clamp value to min/max
          const min = parseFloat(sliders[key].min);
          const max = parseFloat(sliders[key].max);
          const clampedValue = Math.max(min, Math.min(max, value));
          
          params[key] = clampedValue;
          numberInputs[key].value = clampedValue;
          sliders[key].value = clampedValue;
          createTable();
        });
      });
      
      // Reset camera
      document.getElementById("resetCamera").addEventListener("click", () => {
        // Reset camera to initial position
        controls.reset();
        
        // Enable auto-rotation again
        isAutoRotating = true;
        controls.autoRotate = true;
      });
    </script>
  </body>
</html>
